// TESTS FOR MKtlDesc ///

/***************

TODO TODO TODO - clenup pact items
// * test support for new format of assocArrays in desc files

// * this osc controller creates a weird name:
MKtlDesc.at(\srcp3141731416127001).idInfo;

// * broken because of new AssocArray format, as in nanoKONTROL ...
// tried supporting it in traverseDo, not fully tested yet.
// ... will finish later.
MKtlDesc.fromFileName("nanoKO*2");



// create an ordered Event class to handle this?
// optimize for dict style access speed,
// do methods always use order
// support ordered named subsets of names, as in MFunc
// support ordered modes with on/off flags

MList?

OE([a: 1, b: 1]
[\a -> 1].atKey;
[\a, 1].atKey
(a: 1).atKey;
[\a -> 1].putAtKey(\b, 2);
[\a, 1].atKey(
(a: 1).atKey;

(a: 1, b: 2).flopWith

******************************************/

/******* typical use: **********/

// lookup if already there, or make it from file
MKtlDesc('nanoPAD2'); // nanoPAD2

// make the one you need by filename
MKtlDesc.fromFileName("nanoKEY2");

// this lists all files in readable form
MKtlDesc.findFile(postFound: true).do(_.basename).printcsAll; "";

// check which ones are already loaded
MKtlDesc.postLoaded;
MKtlDesc('nanoKEY2')
MKtlDesc('nanoKEY2').checkMIDIMsgTypes;

MKtlDesc.checkMsgTypes;
	*checkMsgType
		// this is to check which responders to build
	*elementMsgTypes { |
		var types = Set.new;
		elementsDict.do { |el|
			var type = el[\midiMsgType];
			type ?? {
				warn("" + this + ": element % has no midiMsgType.%".format(el));
			};
			types.add(type);
		};
		^types;
	}


/******************************************/

// some more ways to make MKtlDescs
// according to current definition,
// \idInfo, \protocol, \description are required in a desc dict, so
d = (idInfo: \yoho, description: [], filename: "yoho", protocol: \osc)
MKtlDesc.fromDict(d);
MKtlDesc.fromPath(MKtlDesc.findFile.choose);
MKtlDesc.fromFileName("nanoKEY2");
MKtlDesc.fromFileName("nano*");

MKtlDesc.allDescs.choose.openFile;


/******************************************/
// instvars and basic method tests:
x.dump;
x.fullDesc 		// the desc dict as from file
x.idInfo		// the name with which the system regoisters it
x.shortName		// autogenerated shortcut name for it
x.protocol		// the protocol(s) it uses
x.elementsDesc	// the description of all the elements it has


/******************************************/
// CLASS METHOD TESTs:
MKtlDesc.folderName.cs		// how its folder should be named
MKtlDesc.defaultFolder.cs	// the one that comes with modality
MKtlDesc.fileExt.cs			// the file extension for desc files
MKtlDesc.allDescs;			// all currently loaded descs

MKtlDesc.addFolder("~/Desktop/").cs; // add your own
// if there is no folder there, it posts how to make it:
File.mkdir("~/Desktop/".standardizePath);

MKtlDesc.loadDescs(folderIndex: 1);
MKtlDesc.writeCache;

MKtlDesc.findFile(postFound: true); ""; // this lists all files

MKtlDesc.descFolders.cs;
MKtlDesc.openFolder(0);		// open them by index
MKtlDesc.openFolder(1);

MKtlDesc.loadDescs; // loads all descs from all folders
MKtlDesc.loadDescs("Steinberg*", 0); // match specific filename and folderIndex

MKtlDesc.postLoaded;


// lookupDict for filename/idInfo:
MKtlDesc.fileToIDDict;
MKtlDesc.idInfoFor("ShermanFB2");
MKtlDesc.filenameFor("Steinberg CMC-FD");

/******************************************/
// background methods
// file filenames of desc files:
MKtlDesc.findFile("nanoKEY2");			// single
MKtlDesc.findFile("nano*").cs;			// matching
MKtlDesc.findFile("Stein*").cs;
MKtlDesc.findFile(postFound: true); ""; // this lists all files

MKtlDesc.isValidDescDict((idInfo: \yoho, description: [], filename: "yoho")

