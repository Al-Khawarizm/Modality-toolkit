// TESTS FOR MKtlDesc ///

/***************

TODO TODO TODO - clenup pact items
// * test support for new format of assocArrays in desc files

// * this osc controller creates a weird name:
MKtlDesc.at(\srcp3141731416127001).idInfo;

// * broken because of new AssocArray format, as in nanoKONTROL ...
// tried supporting it in traverseDo, not fully tested yet.
// ... will finish later.
MKtlDesc.fromFileName("nanoKO*2");



// create an ordered Event class to handle this?
// optimize for dict style access speed,
// do methods always use order
// support ordered named subsets of names, as in MFunc
// support ordered modes with on/off flags

MList?

OE([a: 1, b: 1]
[\a -> 1].atKey;
[\a, 1].atKey
(a: 1).atKey;
[\a -> 1].putAtKey(\b, 2);
[\a, 1].atKey(
(a: 1).atKey;

(a: 1, b: 2).flopWith

******************************************/

/******* typical user interface code: **********/

// lookup if already there by filename;
// if not there, make it from file
MKtlDesc('nanoPAD2'); // nanoPAD2

// explicitly make the one you need by filename
// i.e. reload from file if it was loaded already
MKtlDesc.fromFileName("nanoKEY2");

// this lists all files in readable form
MKtlDesc.postLoadable;
// check which ones are already loaded
MKtlDesc.postLoaded;
MKtlDesc('nanoKEY2');
MKtlDesc('nanoKEY2').checkMIDIMsgTypes;
MKtlDesc('nanoKONTROL2').checkMIDIMsgTypes;

MKtlDesc('nanoKONTROL2').elementsAssocArray.collect(_.key);

MKtlDesc('nanoKONTROL2').getMidiMsgTypes;
MKtlDesc('nanoKONTROL2').fullDesc[\msgTypesUsed];
MKtlDesc('nanoKONTROL2').fullDesc[\elementsWithNoType];

m.openFile;
m = MKtlDesc('nanoKONTROL2');
m.fullDesc.put(\msgTypesUsed, Set.new);
MKtlDesc('nanoKONTROL2').elementsDesc
.traverseDo ({ |elem, deepKeys|
	var elemKey = deepKeys.join($_).asSymbol;
	var msgType;

	elem.put(\elemKey, elemKey);
	MKtlDesc.fillMidiDefaults(elem);
	msgType = elem[\midiMsgType];

	if (msgType.notNil) {
		m.fullDesc[\msgTypesUsed].add(msgType);
	};
	[elemKey, elem].postln;
}, MKtlDesc.isElementTestFunc); "";
m.fullDesc.at(\msgTypesUsed);


	*checkMsgType
		// this is to check which responders to build
	*elementMsgTypes { |
		var types = Set.new;
		elementsDict.traverseDo { |el|
			var type = el[\midiMsgType];
			type ?? {
				warn("" + this + ": element % has no midiMsgType.%".format(el));
			};
			types.add(type);
		};
		^types;
	}


/******************************************/

// some more ways to make MKtlDescs
// according to current definition,
// \idInfo, \protocol, \description are required in a desc dict, so
d = (idInfo: \yoho, description: [], filename: "yoho", protocol: \osc)
MKtlDesc.fromDict(d);
MKtlDesc.fromPath(MKtlDesc.findFile.choose);
MKtlDesc.fromFileName("nanoKEY2");
MKtlDesc.fromFileName("nano*");

MKtlDesc.allDescs.choose.openFile;


/******************************************/
// instvars and basic method tests:
x.dump;
x.fullDesc 		// the desc dict as from file
x.idInfo		// the name with which the system regoisters it
x.shortName		// autogenerated shortcut name for it
x.protocol		// the protocol(s) it uses
x.elementsDesc	// the description of all the elements it has


/******************************************/
// CLASS METHOD TESTs:
MKtlDesc.folderName.cs		// how its folder should be named
MKtlDesc.defaultFolder.cs	// the one that comes with modality
MKtlDesc.fileExt.cs			// the file extension for desc files
MKtlDesc.allDescs;			// all currently loaded descs

MKtlDesc.addFolder("~/Desktop/").cs; // add your own
// if there is no folder there, it posts how to make it:
File.mkdir("~/Desktop/".standardizePath);

MKtlDesc.loadDescs(folderIndex: 1);
MKtlDesc.writeCache;

MKtlDesc.findFile(postFound: true); ""; // this lists all files

MKtlDesc.descFolders.cs;
MKtlDesc.openFolder(0);		// open them by index
MKtlDesc.openFolder(1);

MKtlDesc.loadDescs; // loads all descs from all folders
MKtlDesc.loadDescs("Steinberg*", 0); // match specific filename and folderIndex

MKtlDesc.postLoadable(1);
MKtlDesc.postLoaded;

MKtlDesc('nanoKONTROL2') == MKtlDesc('nanoKONTROL2')

MKtlDesc("nanoKO*2") == MKtlDesc("nanoKO*2"); // not true yet
// hmm, would have to match for available names
MKtlDesc("nanoKONTROL2") == MKtlDesc("nanoKONTROL2"); // true


m = MKtlDesc('nanoKONTROL2');
m.openFile;
m.elementsDesc.printAll;"";
m.checkMIDIMsgTypes
n = MKtlDesc('QuNexus');
n.checkMIDIMsgTypes


/******************************************/
// background methods

// lookupDict for filename/idInfo:
MKtlDesc.fileToIDDict;
MKtlDesc.writeCache;
MKtlDesc.loadCache;
MKtlDesc.idInfoFor("ShermanFB2");
MKtlDesc.filenameFor("Steinberg CMC-FD");

// file filenames of desc files:
MKtlDesc.findFile("nanoKEY2");			// single
MKtlDesc.findFile("nano*").cs;			// matching
MKtlDesc.findFile("Stein*").cs;
MKtlDesc.findFile(postFound: true); ""; // this lists all files

MKtlDesc.isValidDescDict((idInfo: \yoho, description: [], filename: "yoho")

