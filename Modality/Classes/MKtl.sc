// honouring Jeff's MKeys by keeping the M for prototyping the new Ktl


MKtl : MAbstractKtl { // abstract class
	classvar <deviceDescriptionFolder; //path of MKtlSpecs folder
	classvar <allDevDescs; // contains the identity dictionary in index.desc.scd
	//i.e. (BCR2000 -> ( 'osx': ( 'device': BCR2000 ), 'device': BCR2000, 'protocol': midi, 'file': BCR2000.desc.scd ))
	classvar <all; // holds all instances of MKtl
	classvar <specs; // ( 'specName': ControlSpec, ...) -> all specs
	classvar <allAvailable; // ( 'midi': List['name1',... ], 'hid': List['name1',... ], ... )

	// tree structure composed of dictionaries and arrays with a description of all the elements on the device.
	// read from an external file.
	var <deviceDescriptionHierarch;

	// an array of keys and values with a description of all the elements on the device.
	// generated from the hierarchical description read from the file.
	var <deviceDescription;
	//of type: [ 'elemName', ( 'mode': Symbol, 'chan': Int, 'type': Symbol, 'specName': Symbol,
	//'midiMsgType': Symbol, 'spec':ControlSpec, 'ccNum': Int )
	// i.e. [ prA1, ( 'mode': toggle, 'chan': 0, 'type': button, 'specName': midiBut,
	//'midiMsgType': cc, 'spec': a ControlSpec(0, 127, 'linear', 127, 0, ""), 'ccNum': 105 )


	//var <>recordFunc; // what to do to record incoming control changes

	classvar <exploring = false;

	*initClass {
		Class.initClassTree(Spec);
		all = ();
		allAvailable = ();

		specs = ().parent_(Spec.specs);

		// general
		this.addSpec(\cent255, [0, 255, \lin, 1, 128]);
		this.addSpec(\cent255inv, [255, 0, \lin, 1, 128]);
		this.addSpec(\lin255,  [0, 255, \lin, 1, 0]);
		this.addSpec(\cent1,  [0, 1, \lin, 0, 0.5]);
		this.addSpec(\lin1inv,  [1, 0, \lin, 0, 1]);

		// MIDI
		this.addSpec(\midiNote, [0, 127, \lin, 1, 0]);
		this.addSpec(\midiCC, [0, 127, \lin, 1, 0]);
		this.addSpec(\midiVel, [0, 127, \lin, 1, 0]);
		this.addSpec(\midiBut, [0, 127, \lin, 127, 0]);
		this.addSpec(\midiTouch, [0, 127, \lin, 1, 0]);
		this.addSpec(\midiBend, [0, 16383, \lin, 1, 8192]);

		// HID
		this.addSpec(\hidBut, [0, 1, \lin, 1, 0]);
		this.addSpec(\hidHat, [0, 1, \lin, 1, 0]);
		this.addSpec(\compass8, [0, 8, \lin, 1, 1]); // probably wrong, check again!

		this.addSpec(\cent1,  [0, 1, \lin, 0, 0.5].asSpec);
		this.addSpec(\cent1inv,  [1, 0, \lin, 0, 0.5].asSpec);

		deviceDescriptionFolder = this.filenameSymbol.asString.dirname.dirname +/+ "MKtlSpecs";
	}

	*find { |protocols|
		if ( Main.versionAtLeast( 3, 7 ) ){
			protocols = protocols ? [\midi,\hid];
		}{
			protocols = protocols ? [\midi];
		};
		/*
		if ( protocols.isNil ){
			this.allSubclasses.do(_.find( post: false ) );
			"\n-----------------------------------------------------".postln;
			this.allSubclasses.do(_.postPossible() );
		}{*/
		protocols.asCollection.do{ |pcol|
			this.matchClass(pcol) !? _.find
		}
	// };
	}

	*addSpec {|key, spec|
		specs.put(key, spec.asSpec);
	}

	*makeShortName {|deviceID|
		^(deviceID.asString.toLower.select{|c| c.isAlpha && { c.isVowel.not }}.keep(4)
			++ deviceID.asString.select({|c| c.isDecDigit}))
	}

	*matchClass { |symbol|
		^this.allSubclasses.detect({ |x| x.protocol == symbol })
	}

	// new returns existing instances
	// of subclasses that exist in .all,
	// or returns a new empty instance.
	// this is to allow virtual MKtls eventually.
	*new { |name, deviceDescName|
		var devDesc, return;
		if(MKtl.allDevDescs.isNil){
			MKtl.loadAllDescs
		};
		^if ( this.checkName( name, deviceDescName ).not ){
			nil;
		} {
			if (deviceDescName.isNil) {
				(if ( all[name].notNil ){
					//MKtl already exists, return it
					all[name];
				} {
					//get available devices
					MIDIMKtl.initMIDI;
					if ( Main.versionAtLeast( 3, 7 ) ){
						HIDMKtl.initHID;
					};
					// it does not exist yet, but maybe it has a spec that fits?
					// there is no device description, but maybe this was an autogenerated name for a
					// known device, so let's open it
					// look in the allAvailable dict
					return = allAvailable.select(_.includes(name))
					.keys.as(Array)[0];

					if(return.notNil) {
						return = MKtl.matchClass(return);
						if( return.notNil ) {
							return.new( name )
						} {
							nil
						}
					} {
						//no devices matching were found
						//perhaps the device is not connected but the deviceDescName
						//matchs a known device so we create a virtual version with gui
						this.prMakeVirtual(name)
					}
				}) ?? {
					//all else has failed...
					Error("MKtl*new : no deviceDescName was supplied and name doesn't match any shortname for a known device").throw
				}
			} {
				// create an instance of the right subclass based on the protocol given in the device description
				devDesc = this.getDeviceDescription( deviceDescName );
				MKtl.matchClass(devDesc[ \protocol ]) !?
				_.newFromDesc( name, deviceDescName, devDesc ) ?? {
					this.basicNew(name, deviceDescName)
				}
			}
		}
	}

	*basicNew { |name, deviceDescName|
		^super.new.init(name, deviceDescName);
	}

	*fake { |deviceDescName|
		var g = { |i|
			if(MKtl.all.keys.includes("virtual_%_%".format(i, deviceDescName).asSymbol)) {
				g.(i+1)
			} {
				"virtual_%_%".format(i, deviceDescName).asSymbol
			}
		};
		^this.make(g.(0), deviceDescName)
	}

	*make { |name, deviceDescName|
		if (all[name].notNil ) {
			warn("MKtl name '%' is in use already. Please use another name."
				.format(name));
			^nil
		};
		^this.basicNew( name, deviceDescName )
	}

	*prShortnamesToDevices {
		if( MKtl.allDevDescs.isNil ){ MKtl.loadAllDescs };
		^Dictionary.with(*
			MKtl.allDevDescs.getPairs.clump(2)
			.collect({ |xs| (MKtl.makeShortName(xs[1][\device]) -> xs[0]) }))
	}

	*prMakeVirtual { |name|
		var t,r,shortNames,deviceDescName;
		if(MKtl.allDevDescs.isNil){
			MKtl.loadAllDescs
		};
		t = name.asString;
		r = t[..(t.size-2)];
		//shortnames are generated from 'device' entry of description file entries
		^this.prShortnamesToDevices[r] !? { |deviceDescName|
			MKtl.matchClass(allDevDescs[deviceDescName][ \protocol ]) !? { |class|
				var temp = class.fake( deviceDescName );
				if ( all[name].isNil ){
					all.put( name, temp );
				};
				temp.gui;
				temp
			}
		}
	}

	*checkName { |name, deviceDescName|
		if (all[name].notNil and: deviceDescName.notNil ) {
			warn("MKtl name '%' is in use already. Please use another name."
				.format(name));
			^false
		};
		^true
	}

	/*

	init procedure:

	- load description from file into deviceDescription var
	- flattenDescription on each element
	- substitute each spec in the element for the real ControlSpec corresponding to it


	*/
	init { |argName, deviceDescName|
		name = argName;

		//envir = ();
		elementsDict = ();
		if (deviceDescName.isNil) {
			warn("no deviceDescription name given!");
		} {
			this.loadDeviceDescription(deviceDescName);
			if ( deviceDescription.notNil ){
				this.makeElements;
				( "Opened device:" + name + "using device description"+deviceDescName ).postln;
			};
		};
		all.put(name, this);
	}
	storeArgs { ^[name] }
	printOn { |stream| this.storeOn(stream) }

	*loadAllDescs { |reload=false|
		if ( allDevDescs.isNil or: reload ){
			var paths = (deviceDescriptionFolder++"/*.desc.scd").pathMatch;
			var descNames = paths.collect{ |x|
				PathName(x).fileName.split($.)[0]
			};
			allDevDescs = IdentityDictionary.with(
				*[descNames, paths].flop.collect{ |xs|
					var dict = (xs[1].cs++".load").interpret;
					dict ?? {
						"%.desc.scd does not parse".format(xs[0]).warn;
					};
					xs[0].asSymbol -> dict
				}.select(_.notNil)
			)
			//ignore entrys without a description
			.select{ |val, key|
				var bool = val.isKindOf(IdentityDictionary) and: {
					val.keys.includes(\description)
				};
				if(bool.not) {
					"%.desc.scd is not a valid description file".format(key).warn
				};
				bool
			};
		};
	}

	*getDeviceDescription { |devName|
		var devDesc;
		this.loadAllDescs;
		devDesc = allDevDescs.at( devName );
		^devDesc ?? {
			// see if we can find it from the device name:
			allDevDescs
			.as(Array)
			.select{ |desc| desc[\type] != \template }
			.collect{ |desc| this.flattenDescription( desc ) }
			.detect{ |desc| desc[ \device ] == devName }
		}
	}

	loadDeviceDescription { |deviceName|
		var deviceInfo;
		var deviceFileName;
		var path;

		//get device info from stored list
		deviceInfo = this.class.getDeviceDescription( deviceName ).deepCopy;
		//"class: % deviceName: % deviceInfo:%".format(deviceName.class, deviceName, deviceInfo).postln;
		if ( deviceInfo.notNil ){

			deviceDescriptionHierarch = deviceInfo !? _[\description] ?? {
				"%: - no device description found for %: please make it!\n"
				.postf(this.class, deviceName);
				//	this.class.openTester(this);
			};

			deviceDescription = this.makeFlatDeviceDescription( deviceDescriptionHierarch );

			deviceDescription.pairsDo{ |key,elem|
				this.class.flattenDescription( elem )
			};

			// create specs
			deviceDescription.pairsDo {|key, elem|
				var foundSpec =  specs[elem[\spec]];
				if (foundSpec.isNil) {
					warn("Mktl - in description %, el %, spec for '%' is missing! please add it via:"
						"\nMktl.addSpec( '%', [min, max, warp, step, default]);\n"
						.format(deviceName, key, elem[\spec], elem[\spec])
					);
				};
				elem[\specName] = elem[\spec];
				elem[\spec] = this.class.specs[elem[\specName]];
			};

			deviceInfo[\infoMessage] !? _.postln;
		}{ // no device file found:
			this.warnNoDeviceFileFound(deviceName);
		}
	}

	//traversal function for combinations of dictionaries and arrays
	prTraverse {
		var isLeaf = { |dict|
			dict.values.any({|x| x.size > 1}).not
		};

		var f = { |x, state, stateFuncOnNodes, leafFunc|

			if(x.isKindOf(Dictionary) ){
				if( isLeaf.(x) ) {
					leafFunc.( state , x )
				}{
					x.sortedKeysValuesCollect{ |val, key|
						f.(val, stateFuncOnNodes.(state, key), stateFuncOnNodes, leafFunc )
					}
				}
			} {
				if(x.isKindOf(Array) ) {
					x.collect{ |val, i|
						f.(val, stateFuncOnNodes.(state, i),  stateFuncOnNodes, leafFunc )
					}
				} {
					Error("MKtl:prTraverse Illegal data structure in device description.\nGot object % of type %. Only allowed objects are Arrays and Dictionaries".format(x,x.class)).throw
				}
			}

		};
		^f
	}

	explore{ |mode=true|
		this.subclassResponsibility(thisMethod)
	}

	prUnderscorify {
		^{ |a,b|
			if(a != "") {
				a++"_"++b.asString
			} {
				b.asString
			}
		};
	}

	makeFlatDeviceDescription { |devDesc|

		var flatDict = ();

		this.prTraverse.(devDesc, "", this.prUnderscorify, { |state, x| flatDict.put(state.asSymbol,  x) } );

		^flatDict.asKeyValuePairs

	}

	*postAllDescriptions {
		(MKtl.deviceDescriptionFolder +/+ "*").pathMatch
		.collect { |path| path.basename.splitext.first }
		.reject(_.beginsWith("_"))
		.do { |path| ("['" ++ path ++"']").postln }
	}

	*flattenDescription { |devDesc|
		// some descriptions may have os specific entries, we flatten those into the dictionary
		var platformDesc = devDesc[ thisProcess.platform.name ];
		if ( platformDesc.notNil ){
			platformDesc.keysValuesDo{ |key,val|
				devDesc.put( key, val );
			}
		};
		^devDesc;
	}

	*flattenDescriptionForIO { |eleDesc,ioType|
		// some descriptions may have ioType specific entries, we flatten those into the dictionary
		var ioDesc = eleDesc[ thisProcess.platform.name ];
		if ( ioDesc.notNil ){
			ioDesc.keysValuesDo{ |key,val|
				eleDesc.put( key, val );
			}
		};
		^eleDesc;
	}


	elementDescriptionFor { |elname|
		^deviceDescription[deviceDescription.indexOf(elname) + 1]
	}

	postDeviceDescription {
		deviceDescription.pairsDo {|a, b| "% : %\n".postf(a, b); }
	}

	makeElements {
		var leafFunc;
		this.elementNames.do{|key|
			elementsDict[key] = MKtlElement(this, key);
		};
		leafFunc = { |finalKey, x| elementsDict[finalKey.asSymbol] };
		elements = this.prTraverse.(deviceDescriptionHierarch, "", this.prUnderscorify, leafFunc );

	}

	// needed for fixing elements that are not present for a specific OS
	replaceElements{ |newelements|
		elementsDict = newelements;
	}

	// convenience methods
	defaultValueFor { |elName|
		^this.elementsDict[elName].defaultValue
	}

	makeElementName { |args|
		var n = args.size;
		^(args[..n-2].collect({ |x| x.asString++"_"}).reduce('++')++args.last).asSymbol
	}

	elementAt { |...args|
		^elements.deepAt1(*args)
	}

	// should filter: those for my platform only
	elementNames {
		if ( elementsDict.isEmpty ){
			^(0, 2 .. deviceDescription.size - 2).collect (deviceDescription[_])
		}{
			^elementsDict.keys.asArray;
		}
	}

	elementsOfType { |type|
		^elementsDict.select { |elem|
			elem.elementDescription[\type] == type
		}
	}

	elementsNotOfType { |type|
		^elementsDict.select { |elem|
			elem.elementDescription[\type] != type
		}
	}

	inputElements{
		^elementsDict.select { |elem|
			[ \in, \inout ].includes( elem.elementDescription[\ioType] ?? \in);
		}
	}

	outputElements{
		^elementsDict.select { |elem|
			[ \out, \inout ].includes( elem.elementDescription[\ioType] ?? \in);
		}
	}

	allElements {
		^elementsDict.asArray
	}

}
