/* To Do:

1. abstract out consecutive note numbers and controller numbers
   in order to generate more compact code

2. check name consistency - is this already creting exactly the recommended names?

*/

MIDIExplorer {

	classvar <allMsgTypes = #[ \noteOn, \noteOff, \cc, \touch, \polytouch, \bend, \program ];

	classvar <resps;
	classvar <observeDict;
	classvar <>verbose = true;
	classvar <observedSrcID;
	classvar <totalSum = 0;

	*shutUp { verbose = false }

	*init {

		resps = [

			MIDIFunc.cc({|val, num, chan, src|
				this.updateRange(\cc, val, num, chan, src);
			}),

			MIDIFunc.noteOn({|val, num, chan, src|
				this.updateRange(\noteOn, val, num, chan, src);
			}),

			MIDIFunc.noteOff({|val, num, chan, src|
				this.updateRange(\noteOff, val, num, chan, src);
			}),

			MIDIFunc.polytouch({|val, note, chan, src|
				this.updateRange(\polytouch, val, note, chan, src);
			}),

			MIDIFunc.bend({|val, chan, src|
				this.updateRange(\bend, val, 0, chan, src);
			}),

			MIDIFunc.touch({|val, chan, src|
				this.updateRange(\touch, val, 0, chan, src);
			}),

			MIDIFunc.program({|val, chan, src|
				this.updateRange(\program, val, 0, chan, src);
			})

		];
	}

	*start { |srcID|
		if (resps.isNil) { this.init };

		observedSrcID = srcID;
		this.prepareObserve;
		resps.do(_.add);
	}

	*stop {
		resps.do(_.clear);
	}

	*postSrcInfo {
		MIDIClient.sources.do { |src, i|
			"i: % - device: % - name: % - uid: % \n".postf(
				i, src.device, src.name, src.uid
			);
		};
	}

	*prepareObserve {
		totalSum = 0;
		observeDict = ();
		allMsgTypes.do(observeDict.put(_, Dictionary()));
	}

	*openDoc {
		Document("edit and save me", this.compile);
	}

	*devName {
		var string;
		var device = MIDIClient.sources.detect{|src| src.uid === observedSrcID};
		if (device.notNil) { ^device.device };
		string = "(please pick device name from posted list:)";
		string.postln;
		this.postSrcInfo;
		^string
	}


	*compile {
		var string =
		"/**** desc file generated by MIDIExplorer.

1. please put any comments about the device here.

2. add minimal code examples for testing, such as:
k = MKtl(<name>);
k.elementAt(\sl, 0).action = { \yo.postln; };

3. consider compressing flat lists of single controls into arrays, e.g.
'_noteOn_0_048_': ('midiMsgType': 'noteOn', 'type': 'key', 'midiChan': 0, 'midiNum':  48, 'spec': 'midiNote'),
// and same for 49, 50, 51 .. 96 ...
(48..96).collect { |midinote|  ('midiMsgType': 'noteOn', 'type': 'key', 'midiChan': 0, 'midiNum':  48, 'spec': 'midiNote') };

****/\n\n"

		"\n(\nvar dict = (device: %, \nprotocol: 'midi');\n\n"
		"dict.put('description', %\n);\n)";

		^string.format(this.devName.asCompileString, this.compileDesc);
	}

	*compileDesc { |includeSpecs = false|

		var num, chan;

		// (device: "Ableton Push", protocol: \midi, description:";

		var str = "(";

		if (observeDict[\noteOn].notEmpty) {
			str = str + "\n// ------ noteOn -------------";
			observeDict[\noteOn].sortedKeysValuesDo { |key, val|
				#chan, num = key.split($_).collect(_.asInteger);
				str = str + "\n'_noteOn_%_': ('midiMsgType': 'noteOn', 'type': 'key', 'midiChan': %, 'midiNum':  %, 'spec': 'midiNote'),"
					.format(key, chan, num);
			};
		};



		if (observeDict[\noteOff].notEmpty) {
			str = str + "\n\n// ---------noteOff ----------";
			observeDict[\noteOff].sortedKeysValuesDo { |key, val|
				#chan, num = key.split($_).collect(_.asInteger);
				str = str + "\n'_noteOff_%_': ('midiMsgType': 'noteOff', 'type': 'key', 'midiChan': %, 'midiNum':  %,'spec': 'midiNote'),"
				.format(key, chan, num);
			};
		};


		if (observeDict[\cc].notEmpty) {
			str = str + "\n\n// ------ cc -------------";
			observeDict[\cc].sortedKeysValuesDo { |key, val|
				#chan, num = key.split($_).collect(_.asInteger);
				str = str + "\n'_cc_%_': ('midiMsgType': 'cc', 'type': 'slider', 'midiChan': %, 'midiNum':  %,'spec': 'midiCC'),"
					.format(key, chan, num);
			};
		};

		if (observeDict[\polytouch].notEmpty) {
			str = str + "\n\n// ------ polytouch -------------";
			observeDict[\polytouch].sortedKeysValuesDo { |key, val|
				#chan, num = key.split($_).collect(_.asInteger);
				str = str + "\n'_polytouch_%_': ('midiMsgType': 'polyTouch', 'type': 'keytouch', 'midiChan': %, 'midiNum':  %,'spec': 'midiCC'),"
					.format(key, chan, num);
			};
		};

		if (observeDict[\touch].notEmpty) {
			str = str + "\n\n// ------- touch ------------";
			observeDict[\touch].sortedKeysValuesDo { |key, val|
				#chan, num = key.split($_).collect(_.asInteger);
				str = str + "\n'_touch_%_': ('midiMsgType': 'touch', 'type': 'chantouch', 'midiChan': %, 'midiNum':  %,'spec': 'midiTouch'),".format(key, chan, num);
			};
		};

		if (observeDict[\bend].notEmpty) {
			str = str + "\n\n// ------- bend ------------";
			observeDict[\bend].sortedKeysValuesDo { |key, val|
				#chan, num = key.split($_).collect(_.asInteger);
				str = str + "\n'_bend_%_': ('midiMsgType': 'bend', 'type': 'bender', 'midiChan': %, 'midiNum':  %,'spec': 'midiBend'),".format(key, chan, num);
			};
		};

		str = str + "\n";

		str = str + ");";


		if (includeSpecs) {
			str = str + "\n\n// ----- noteOn Specs ----------";
			observeDict[\noteOn].sortedKeysValuesDo { |key, val|
				str = str + "\nMKtl.addSpec( _elName_%_, [%, %, \linear, 0, 0]);".format(key, val[0], val[1]);
			};
			str = str + "\n\n// ----- noteOff Specs ----------";
			observeDict[\noteOn].sortedKeysValuesDo { |key, val|
				str = str + "\nMKtl.addSpec( _elName_%_, [%, %, \linear, 0, 0]);".format(key, val[0], val[1]);
			};
			str = str + "\n\n// ----- CC Specs ----------";
			observeDict[\noteOn].sortedKeysValuesDo { |key, val|
				str = str + "\nMKtl.addSpec( _elName_%_, [%, %, \linear, 0, 0]);".format(key, val[0], val[1]);
			};
			str = str + "\n\n// ----- bend Specs ----------";
			observeDict[\noteOn].sortedKeysValuesDo { |key, val|
				str = str + "\nMKtl.addSpec( _elName_%_, [%, %, \linear, 0, 0]);".format(key, val[0], val[1]);
			};
		};

		^str;
	}

	*postObs { |post = false|
		var total = observeDict.collect(_.size).sum;
		if (total > totalSum or: post) {
			"\nMIDIExplorer \n- total number of controls so far: %\n".postf(total);
			allMsgTypes.do { |type|
				var dict = observeDict[type], size;
				if (dict.notNil and: { size = dict.size; size > 0 }) {
					"  %: %".postf(type, size);
				};
			};
			totalSum = total;
			"".postln;
		};
	}

	*updateRange { |msgType, val, num, chan|
		var hash, range;
		var msgDict = observeDict[msgType];

		if (verbose) { [msgType, val, num, chan].postcs; } { ".".post; };
		this.postObs;

		hash = "%_%".format(chan, (num + 1000).asString.drop(1));
		range = msgDict[hash];
		range.isNil.if{
			// min max
			msgDict[hash] = range = [val, val];
		};

		msgDict[hash] = [min(range[0], val), max(range[1], val)];
	}
}
