title:: Modality
summary:: A toolkit for creating flexible personal electronic instruments using a variety of  controllers.
categories:: Libraries>Modality, External Control
related:: Overviews/Modality, Classes/MKtl, Tutorials/ModalityTutorial




The Modality toolkit simplifies using controllers in your SuperCollider patchers. It was created by a team of developers and users of SuperCollider.

link::http://modality.bek.no/::


section::Features
list::
##Modality allows the creation of highly personal instruments by using a wide variety of controllers. To this end, a common code interface, MKtl, is used to set up controllers from various sources and protocols like HID, MIDI and OSC.
##With the Modality toolkit, the same set of physical interfaces (sliders, buttons, motion sensors etc etc) can be easily adapted to control many different processes. Modality was build to allow a highly modal approach to mapping and on-the-fly remapping to make a setup much more flexible, powerful, and interesting to play. For example, when improvising with acoustic musicians, highly modal interfaces allow much faster changes of overall musical direction.
## The toolkit allows quick substitution of controllers for others, whether for experiment (how do the sounds in my setup feel when played with a gaming joystick instead of this faderbox?) or in emergencies (My faderbox broke and I have 30 minutes until the show starts!).
::


section:: Tutorials and further reading

LIST::
##Begin here:

link::Tutorials/ModalityTutorial::

##Supported Devices are:

link::https://modalityteam.github.io/controllers/::
code::
// or in SC:
MKtlDesc.web;
::

##Tutorials for special modality features:

link::Tutorials/Creating_Custom_ElementGroups::

link::Tutorials/Substituting_MKtls::

link::Tutorials/Composing_MKtls::

link::Tutorials/Paging_MKtls::

link::Tutorials/Using_multiple_MKtls_for_one_device:: convert Tests/MKtlPolyphony_HID.scd

link::Tutorials/Using_multiple_identical_devices::

link::Tutorials/Connecting_external_MIDI_devices::

link::Tutorials/Connecting_multi-port_MIDI_devices::



Find many tutorial files and examples of common use cases of MKtl here:
link::https://github.com/ModalityTeam/ModalityWorkshop::

Also, many description files have little examples for their device:
code::
MKtlDesc.openFolder;
MKtlDesc.loadDescs.choose.openFile;
::

And longer examples for specific devices are here:
code::
(MKtlDesc.defaultFolder.dirname +/+ "DeviceExamples").openOS;
::

::

section:: Advanced Tutorials and further reading
LIST::
## Adding your own controller(s) to Modality:

link::Tutorials/How_to_adapt_a_description_file::

link::Tutorials/How_to_create_a_description_file::
::


SECTION:: First steps

This section is intended as a rough and quick overview. For more detailed information, see link::Tutorials/ModalityTutorial::.

Use code::MKtl:: to assign functionality to hardware controller elements. To find your device, evaluate
code::
MKtl.find;
::

NOTE:: You may have to install drivers before code::MKtl.find:: is able to find your device. Some devices may show up in multiple protocols. Example: the code::ICON IControls:: show up as both code::MIDI:: and code::HID::.::


Each code::MKtl:: comprises of code::MKtlElement::s, representing part of your controller such as sliders or knobs. You can assign custom actions to such elements. They will get evaluated every time the value of that element is updated.

subsection:: Example NanoKontrol2

code::
// plug in a NanoKontrol2 and evaluate this line.
// ( if you don't have one at hand, do it anyhow :)
k = MKtl('nk2', "korg-nanokontrol2");

// alternatively, you can evaluate
MKtl.find(\midi);
// grab the last line pasted, and change its name:
k = MKtl('nk2', "korg-nanokontrol2");

// If no controller is connected, use its gui instead:
k.gui;


// turn on trace, then move some elements to see that it works
k.trace;
k.trace(false);

// If no such controller is connected, use its gui instead:
k.gui;

// the elements (knobs, sliders, buttons) are in hierarchical groups
k.elementGroup;
k.postElements;

// elements can be accessed by hierarchical names or indices:
k.elAt(\kn, 0);
k.elAt(\kn, \1);
k.elAt(\tr, \play);
k.elAt(\bt, 1, 4);
k.elAt(\bt, \M, \5);


// make sure there are no current assigned actions
k.resetActions;

// boot the server
s.boot;

(
// play a sound
x = {
	Splay.ar(
		SinOsc.ar([
			\freq1.kr(700, lag: 0.3),
			\freq2.kr(150, lag: 0.3),
			\freq3.kr(100, lag: 0.3)
	]))/3
}.play;

// add a spec for the controls
Spec.add(\freq1, [100, 1000, \exp]);
)

// set actions to the first three sliders
(
k.elAt(\sl, 0).action = {arg el; x.set(\freq1, \freq1.asSpec.map(el.value)) };
k.elAt(\sl, 1).action = {arg el; x.set(\freq2, \freq1.asSpec.map(el.value)) };
k.elAt(\sl, 2).action = {arg el; x.set(\freq3, \freq1.asSpec.map(el.value)) };
)

// after testing, free sound
x.free;

// and free the device
k.free;
::

subsection:: Example BCR2000

code::
// plug in your BCR2000 and evaluate this line.
k = MKtl('myBCR', "behringer-bcr2000");

// turn on trace, then move some elements to see that it works
k.trace;
k.trace(false);

// If no such controller is connected, use its gui instead:
k.gui;

// make sure there are no current assigned actions
k.resetActions;

// the elements (knobs, sliders, buttons) are in hierarchical groups
k.elementGroup;
k.postElements;

// elements can be accessed by hierarchical names or indices:
k.elAt(\kn, 0);
k.elAt(\kn, 0, 0);

// all knobs of the first row
k.elAt(\kn, 0); // -> MKtlElementGroup

// elements have a type:
k.elAt(\kn, 0, 0).type;

// select elements by their type:
k.elementsDict.select { |x| x.type == \encoder };

// perform an action on turning knob [0,0] (upper left)
k.elAt(\kn, 0, 0).action = { |el| [el.name, el.value.round(0.001)].postln };

// boot the server
s.boot;

// simple sound example
x = { Splay.ar(RLPF.ar(Saw.ar(\freq.kr(440, 0.1), mul: 0.1), 1000))}.play;

// .action overrides previously set actions
(
k.elAt(\kn, 0, 0).action_({ |el|
	x.set(\freq, el.value.linlin(0.0, 1, 300.0, 600));
});
)

// after testing, free sound
x.free;

// send data back to the device
k.elAt(\kn,0,0).value_(0.5);

// remove all assigned actions
k.resetActions;
::


subsection::Bonus: Knob rotation demo
code::
(
d = 0;
{
	loop {
		0.05.wait;
		d = d + 0.01;
		8.do { |i|
			k.elAt(\kn, 0, i).value_(
				(d + (i/7)).mod(1.0);
			);
		};
	}
}.fork;
)
::

SECTION:: Adding unknown Controllers

Have a controller that is not yet known to the Modality? You can add it by yourself!
See link::Tutorials/How_to_create_a_description_file::.

section:: Acknowledgements

Modality and its research meetings have kindly been supported by BEK in Bergen, Norway, and STEIM, Amsterdam.
The ModalityTeam is, in no particular order: Jeff Carey, Bj√∏rnar Habbestad, Marije Baalman, Alberto de Campo, Tijs Ham, Wouter Snoei, Till Bovermann, Miguel Negrao, Robert van Heumen, Hannes Hoelzl, Tim Blechmann, Amelie Hinrichsen, and Dominik Hildebrand Marques Lopes.
