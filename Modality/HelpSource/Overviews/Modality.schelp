title:: Modality
summary:: Toolkit to simplify the creation of personal (electronic) instruments utilising hardware and software controllers of any kind.
categories:: Libraries>Modality, External Control
related:: Overviews/Modality, Classes/MKtl, Reference/SupportedDevices

Section:: Introduction

Modality is a toolkit created by a team of developers and (advanced) users of SuperCollider.

One of its basic ideas is to simplify the creation of your very personal instruments with SuperCollider, using controllers of many different kinds. To this end, a common code interface, MKtl, is used for connecting  controllers from different sources (and protocols) like HID and MIDI, Serial, OSC, GUI, etc.

A second starting point is that the same physical interfaces (sets of sliders, buttons, motion sensors etc etc) can be used for many different purposes, and a highly modal approach to mapping and on-the-fly remapping can help to make a setup much more flexible, powerful, and interesting to play. For example, when improvising with acoustic musicians, highly modal interfaces allow much faster changes of overall (performing) direction.

http://modality.bek.no/



subsection:: Acknowledgements
Modality and its research meetings have kindly been supported by BEK in Bergen, Norway, and STEIM, Amsterdam.
The ModalityTeam is, in no obvious order: Jeff Carey, Bjoernar Habbestad, Marije Baalman, Alberto de Campo, Wouter Snoei, Till Bovermann, Miguel Negrao, Robert van Heumen, Hannes Hoelzl, Tim Blechmann, Amelie Hinrichsen, and Dominik Hildebrand Marques Lopes.


section:: Tutorials

LIST::
##link::Tutorials/ModalityTutorial::
##link::Tutorials/How_to_create_a_description_file::
::

SECTION:: Overview

With code::MKtl:: it is possible to assign functionality to controller elements.

Each code::MKtl:: has elements such as slider or knobs. It is possible to assign an action to such an element that is evauated every time, the value of that element gets updated. Below, there are two examples using popular MIDI controller.


subsection:: NanoKontrol2

code::
// plug in your NanoKontrol2 and evaluate this line
k = MIDIMKtl('nnkn20');

// alternatively, create a fake NanoKontrol2
k = MIDIMKtl.make('nnkn20', 'NanoKontrol2');

k.gui; // opens a gui representation of the device

s.boot; // boot the server
s.latency = nil; // reduce latency for messages sent to the server

( // make an Ndef to control
Spec.add(\freq1, \freq);
Spec.add(\freq2, \freq);
Spec.add(\freq3, \freq);
Ndef( \sine ).fadeTime = 0.1;
Ndef( \sine, {
	Pan2.ar(
		Mix.new(
			SinOsc.ar([
				\freq1.kr(400).lag(0.3,0.5),
				\freq2.kr(400).lag(0.3,0.5),
				\freq3.kr(400).lag(0.3,0.5)
			] * [3/4,1,4/3]
		)) / 10,
		0
	)
});
)

// set actions to the first three sliders
k.elements[\sl][0].action_({|elem|Ndef(\sine).set(\freq1,\freq1.asSpec.map(elem.value))});
k.elements[\sl][1].action_({|elem|Ndef(\sine).set(\freq2,\freq2.asSpec.map(elem.value))});
k.elements[\sl][2].action_({|elem|Ndef(\sine).set(\freq3,\freq3.asSpec.map(elem.value))});
::

subsection:: BCR2000

code::
//create a non existing Controller according to template 'BCR2000'

k = MIDIMKtl.make('fakeBCR','BCR2000');
k.elements; //Dictionary of controls keys to MKtlElements
k.gui; // open a gui representation of the device
::

For a real BCR2000 we would use:
code::
k = MIDIMKtl('bcr20000');
k.elements; //Dictionary of controls keys to MKtlElements
k.gui; // open a gui representation of the device
::

Each element can be retrieved from the elements data structure:

code::
k.elements[\kn][0][7]
::

Or it can be retrieved using a shortcut method with symbols:

code::
k.elementAt(\kn,1,7)
::

Elements have a type:

code::
k.elementAt(\kn,1,7).type
::

It's possible to select elements by their type:
code::
k.allElements.select{ |x| x.type == \encoder }
::

To perform an action on an incoming event:

code::
k.elementAt(\kn,1,7).action_({ |el| el.value.postln })


x = { Saw.ar(\freq.kr(440)) * 0.1 }.play;

k.elementAt(\kn,1,7).action_({ |el| x.set(\freq, el.value.linlin(0.0,1.0,300,1000)) })
::

If you want to add multiple actions use addAction and removeAction:

code::
f = { |el| x.set(\freq, el.value.linlin(0.0,1.0,300,1000)) };

k.elementAt(\kn,1,7).addAction(f)
k.elementAt(\kn,1,7).removeAction(f)
::

To send data back to a device one uses link::Classes/MAbstractElement#value_:: :

k.elementAt(\kn,1,7).value_(0.5)

Classic knobs rotating demo for Behringed BCF2000:

code::
(
x = 0;
fork{
	loop{
		0.1.wait;
		x = x + 0.1;
		8.do{ |i|
			MIDIMKtl('bcf20000').elementAt(\kn,1,i+1).value_(
				(x + (i/7)).mod(1.0)
			)
		}
	}
}
)
::

SECTION:: Undescribed Controller

Have a controller that is not known to the system? See link::Tutorials/How_to_create_a_description_file:: on how to set it up.
