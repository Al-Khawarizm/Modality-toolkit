title:: How to create a description file for an OSC device
summary:: How to create a description file to use with the Modality toolkit for an OSC device
categories:: Libraries>Modality
related:: Overviews/Modality, Classes/MKtl, Reference/MKtl_description_files, Classes/OSCMon

Section:: Introduction

The functionality of link::Classes/MKtl:: relies on descriptions of the used devices. For some Controllers, there are already descriptions available, chances are that your device is not among them.

This Tutorial first shows simple examples of OSC interfaces, by emulating them within SuperCollider, and then describes how to create a description file for your interface.


list::
##link::#Simple input::
##link::#Simple output::
##link::#Collective input::
##link::#Collective output::
::

section:: Simple input

A simple OSC input is an OSC interface that sends messages that send only single values with an OSC message, e.g.

code::
// osc message path = /button, value = 1, means the button is on
/button 1
// osc message path = /button, value = 0, means the button is off
/button 0
::

The description of the element then is:

code::
'bt': (
	oscPath: '/button',
	type: 'button',
	ioType: \in
)
::

Or they send an index of the button along, for example if there are two buttons

code::
// osc message path = /button, index = 0, value = 1, means the button is on
/button 0 1
// osc message path = /button, index = 1, value = 0, means the button is off
/button 1 0
::

The description of the elements then is:

code::
(
'bt': [
	(
	oscPath: '/button',
	argTemplate: [ 0 ],
	type: 'button',
	ioType: \in
	),
	(
	oscPath: '/button',
	argTemplate: [ 1 ],
	type: 'button',
	ioType: \in
	)
]
)
::

	Or they send multiple indices of the button along, for example in a grid layout (row and column)

code::
// osc message path = /button, rowindex = 0, columnindex=1, value = 1, means the button is on
/button 0 1 1
// osc message path = /button, rowindex = 1, columnindex=2, value = 0, means the button is off
/button 1 2 0
::

The description of the elements then is:

code::
	(
		'bt': [
			[
				(
					oscPath: '/button',
					argTemplate: [ 0,0 ],
					type: 'button',
					ioType: \in
				),
				(
					oscPath: '/button',
					argTemplate: [ 0,1 ],
					type: 'button',
					ioType: \in
				)
			],
			[
				(
					oscPath: '/button',
					argTemplate: [ 1,0 ],
					type: 'button',
					ioType: \in
				),
				(
					oscPath: '/button',
					argTemplate: [ 1,1 ],
					type: 'button',
					ioType: \in
				)
			]
		]
	);
::

The code::argTemplate:: can also contain code::nil:: if there is an element in the osc message that needs to be ignored while filtering, see: link::#argTemplate matching:: for examples how argTemplates can be matched.

If the osc message sends some other info that we are not interested in inside the message, we can specify at which index we want to read the data (by default we take the last value in the osc message):

code::
// osc message path = /button, value = 1, arbitrary data = "hello", means the button is on
/button 1 "hello"
// osc message path = /button, value = 0, arbitrary data = "hello", means the button is off
/button 0 "hello"
::

The description becomes:

code::
'bt': (
	oscPath: '/button',
	type: 'button',
	valueAt: 1,
	ioType: \in
)
::


After all this explanation, a simple example of an OSC device description with one element:

code::
(
~descInput = (
	idInfo: ( srcPort: NetAddr.langPort, ipAddress: "127.0.0.1" ),
	protocol: \osc,
	description: (
		'kn': (
			oscPath: '/knob',
			argTemplate: [ 1,2 ], // at row 1 and column 2
			valueAt: 3, // valueindex of osc message
			type: 'knob',
			spec: \midiCC,
			ioType: \in
		)
	)
)
);

m = MKtl( \exampleOSCInput, ~descInput );
MKtlDevice.allAvailable // now also shows the opened 'osc device'

// create a gui for the osc device:
m.gui;

// post incoming data
m.trace;

n = NetAddr.new( "127.0.0.1", NetAddr.langPort );

// send messages:
n.sendMsg( '/knob', 1, 2, 63 );

n.sendMsg( '/knob', 1, 2, 35 );

n.sendMsg( '/knob', 1, 2, 34 );

// close the device again
m.closeDevice;
::


section:: Simple output

A simple OSC output is an OSC interface that receives OSC messages with only a value for a single control on the device. For example:

code::
// turn on the led at brightness value 5
/led 5
// turn off the led meaning brightness value 0
/led 0
::

With a description like:

code::
(
'led': (
	oscPath: '/output',
	type': 'led',
	ioType: \out
);
)
::

Just like with the simple input example, we can have indices that define additional arguments that specify which led should be on.

code::
// turn on the led at row 2 and column 3 at brightness value 5
/led 2 3 5
// turn off the led at row 2 and column 3 meaning brightness value 0
/led 2 3 0
::

With a description like:

code::
(
'led': (
	oscPath: '/output',
	argTemplate: [ 2, 3 ],
	type: 'led',
	ioType: \out
);
)
::

If the value needs to be inserted in between identifiers for the message, you can use code::nil:: as the place holder in the code::argTemplate::

code::
// turn on the led at row 2 and column 3 at brightness value 5
/led 2 5 3
// turn off the led at row 2 and column 3 meaning brightness value 0
/led 2 0 3
::

With a description like:

code::
(
'led': (
	oscPath: '/output',
	argTemplate: [ 2, nil, 3 ],
	type: 'led',
	ioType: \out
);
)
::


An example of opening an OSC device from a description and sending output to it:

code::
(
MKtl.addSpec(\pwm8bit, [0, 255, \linear, 1]);
~descOutput = (
	idInfo: ( ipAddress: "127.0.0.1", destPort: NetAddr.langPort ),
	protocol: \osc,
	description: (
		'led': (
			oscPath: '/output',
			argTemplate: [ 2, 3 ], // message will be: "/output" 2 3 <val>
			'type': 'led', spec: \pwm8bit,
			\ioType: \out
		);
	);
);
);

m = MKtl( \exampleOSCoutput, ~descOutput );

OSCFunc.trace( true ); // trace what is coming in

// set a value:
m.elementAt( \led ).value_( 0.6 );
m.elementAt( \led ).value_( 1.0.rand );

// cleanup:
m.closeDevice;
::

section:: Collective input

Some OSC devices will send the data for several elements within one OSC message. For example an OSC message updating all 5 buttons of a device:

code::
/buttons 1 1 0 1 0
::

In this case, we can create a code::collective:: that will listen for the code::/buttons:: message, and pass it on to the elements that are part of the collective:

code::
(
~descCollectiveInput = (
	idInfo: ( ipAddress: "127.0.0.1" ),
	protocol: \osc,
	collectives: (
		buttons: (
			oscPath: 'buttons',
			elements: [ [\bt,0], [\bt,1], [\bt,2], [\bt,3], [\bt,4] ], // the order in this array determines the order how the message is parsed
			ioType: \in
		)
	),
	description: (
		'bt': [
			( type: 'button', ioType: \collectiveIn ),
			( type: 'button', ioType: \collectiveIn ),
			( type: 'button', ioType: \collectiveIn ),
			( type: 'button', ioType: \collectiveIn ),
			( type: 'button', ioType: \collectiveIn )
		]
	);
);
);

m = MKtl( \exampleCollectiveIn, ~descCollectiveInput );
m.trace;

n = NetAddr.new( "127.0.0.1", NetAddr.langPort );
n.sendMsg( "/buttons", 1, 1, 0, 1, 1 );

(
Tdef( \autoaction, {
	loop{
		n.sendMsg( "/buttons", 2.rand, 2.rand, 2.rand, 2.rand, 2.rand );
		1.0.wait;
	};
}).play;
);

m.gui;

::

Similar as with the simple input example, we can use an code::argTemplate:: for the output messages. Any code::nil::s in the template will be assumed to contain relevant data. If you do not want to filter on a particular field, but it is not the required data, then you can use code::valueAt:: to specify the indices within the OSC message that you want to use for the values. See the following examples for clarification:


Matching a simple argument template:

code::
(
~descCollectiveInput = (
	idInfo: ( ipAddress: "127.0.0.1" ),
	protocol: \osc,
	collectives: (
		data: (
			// would fire the do something with the elements inside
			oscPath: '/buttons',
			argTemplate: [ 7 ],
			elements: [ [\bt,0], [\bt,1], [\bt,2], [\bt,3], [\bt,4] ], // the order in this array determines the order how the message is parsed
		ioType: \in
		)
	),
	description: (
		'bt': [
			( type: 'button', ioType: \collectiveIn ),
			( type: 'button', ioType: \collectiveIn ),
			( type: 'button', ioType: \collectiveIn ),
			( type: 'button', ioType: \collectiveIn ),
			( type: 'button', ioType: \collectiveIn )
		]
	);
);
);

m.rebuildFrom( ~descCollectiveInput );

// means messages like this are received:
n.sendMsg( "/buttons", 7, 0, 1, 1, 0, 1 );
// and this is not (4 != 7)
n.sendMsg( "/buttons", 4, 0, 1, 1, 0, 1 );
::


Matching an argument template with the filter at the end:

code::
(
~descCollectiveInput = (
	idInfo: ( ipAddress: "127.0.0.1" ),
	protocol: \osc,

	collectives: (
		data: (
			// would fire the do something with the elements inside
			oscPath: '/buttons',
			argTemplate: [ nil, nil, nil, nil, nil, 7 ],
			elements: [ [\bt,0], [\bt,1], [\bt,2], [\bt,3], [\bt,4] ], // the order in this array determines the order how the message is parsed
			ioType: \in
		)
	),
	description: (
		'bt': [
			( type: 'button', ioType: \collectiveIn ),
			( type: 'button', ioType: \collectiveIn ),
			( type: 'button', ioType: \collectiveIn ),
			( type: 'button', ioType: \collectiveIn ),
			( type: 'button', ioType: \collectiveIn )
		]
	);
);
);

m.rebuildFrom( ~descCollectiveInput );

// means messages like this are received:
n.sendMsg( "/buttons", 0, 1, 1, 0, 1, 7 );
// and this is not (4 != 7 )
n.sendMsg( "/buttons", 0, 1, 1, 0, 1, 4 );
::


Matching an argument template with a wildcard at the beginning, but interesting values are only later on in the message, so using code::valueAt:: explicitly:

code::
(
~descCollectiveInput = (
	idInfo: ( ipAddress: "127.0.0.1" ),
	protocol: \osc,
	collectives: (
		data: (
			// would fire the do something with the elements inside
			oscPath: '/buttons',
			argTemplate: [ nil, 7 ],
			valueAt: [ 3, 4, 5, 6, 7 ],
			elements: [ [\bt,0], [\bt,1], [\bt,2], [\bt,3], [\bt,4] ], // the order in this array determines the order how the message is parsed
			ioType: \in
		)
	),
	description: (
		'bt': [
			( type: 'button', ioType: \collectiveIn ),
			( type: 'button', ioType: \collectiveIn ),
			( type: 'button', ioType: \collectiveIn ),
			( type: 'button', ioType: \collectiveIn ),
			( type: 'button', ioType: \collectiveIn )
		]
	);
);
);

m.rebuildFrom( ~descCollectiveInput );

// means messages like this are received:
n.sendMsg( "/buttons", "blah".scramble, 7, 0, 1, 1, 0, 1 );
// and this is not (4 != 7 )
n.sendMsg( "/buttons", "blah".scramble, 4, 0, 1, 1, 0, 1 );
::


Cleaning up:

code::
m.closeDevice;
::

section:: Collective output

Some OSC devices will listen for data of several elements within one OSC message. For example an OSC message updating all 3 leds of a device:

code::
/leds 1 1 0
::

In this case, we can create a code::collective:: that will send the code::/leds:: message, whenever the value of one of the elements of the collective changes:

code::
(
MKtl.addSpec(\pwm8bit, [0, 255, \linear, 1]);

~descCollectiveOut = (
	idInfo: ( ipAddress: "127.0.0.1", destPort: NetAddr.langPort ),
	protocol: \osc,
	'collectives': (
		leds: (
			oscPath: '/leds',
			elements: [ [\led,0], [\led, 1], [\led, 2] ], // elements that make up the group in order that they should appear in the output message
			argTemplate: [ 7 ], // default arguments to send
			ioType: \out
		)
	),
	description: (
		'led': [
			(
				default: 0, // we need a default value to send out the first time any element changes
				type: 'led', spec: \pwm8bit,
				ioType: \collectiveOut // use a group method to create the output
			),
			(
				default: 0, // we need a default value to send out the first time any element changes
				type: 'led', spec: \pwm8bit,
				ioType: \collectiveOut // use a group method to create the output
			),
			(
				default: 0, // we need a default value to send out the first time any element changes
				type: 'led', spec: \pwm8bit,
				ioType: \collectiveOut // use a group method to create the output
			)
		]
	);
);
);

m = MKtl( \exampleCollectiveOut, ~descCollectiveOut );

// test to see what OSC messages are coming in:
OSCFunc.trace( true );

m.elementAt( \led, 1 ).value_( 0.5 );

m.elementAt( \led, 2 ).value_( 0.8 );

m.elementAt( \led, 0 ).value_( 0.1 );

(
Tdef( \autoaction, {
	loop{
		m.elementAt( \led, 0 ).value_( 1.0.rand );
		1.0.wait;

		m.elementAt( \led, 1 ).value_( 1.0.rand );
		1.0.wait;

		m.elementAt( \led, 2 ).value_( 1.0.rand );
		1.0.wait;
	};
}).play;
);

m.gui;

Tdef( \autoaction ).stop;

::

If the value needs to be inserted in between identifiers for the message, you can use code::nil:: as the place holder in the code::argTemplate::

code::

(
MKtl.addSpec(\pwm8bit, [0, 255, \linear, 1]);

~descCollectiveOut = (
	idInfo: ( ipAddress: "127.0.0.1", destPort: NetAddr.langPort ),
	protocol: \osc,
	'collectives': (
		leds: (
			oscPath: '/leds',
			elements: [ [\led,0], [\led, 1], [\led, 2] ], // elements that make up the group in order that they should appear in the output message
			argTemplate: [ nil, 7, nil, 9, 10 ], // default arguments to send elements take up position 0, 2 and 5 and so on.
			ioType: \out
		)
	),
	description: (
		'led': [
			(
				default: 0, // we need a default value to send out the first time any element changes
				type: 'led', spec: \pwm8bit,
				ioType: \collectiveOut // use a group method to create the output
			),
			(
				default: 0, // we need a default value to send out the first time any element changes
				type: 'led', spec: \pwm8bit,
				ioType: \collectiveOut // use a group method to create the output
			),
			(
				default: 0, // we need a default value to send out the first time any element changes
				type: 'led', spec: \pwm8bit,
				ioType: \collectiveOut // use a group method to create the output
			)
		]
	);
);
);

m.rebuildFrom( ~descCollectiveOut );

Tdef( \autoaction ).play;

::


Cleaning up:

code::
m.closeDevice;
::


section:: Explore your device


section:: Reviewing the exploration

subsection:: Build a description file from the raw data

To bring these into a form useable as a description file for Modality, we have to put it into the format specified in link::Reference/MKtl_description_files:::

code::
(
\identifier: (key: value, key: value, ... ),
\identifier: (key: value, key: value, ... ),

\groupIdentifier: [
	(key: value, key: value, ... ),
	(key: value, key: value, ... ),
	(key: value, key: value, ... ),
]
)
::

note::Naming conventions apply. You can find them at link::Reference/MKtl_description_files#Naming Conventions::.
::

Edit the code::edit and save me.desc.scd:: document to assemble your new description file. Make sure you pay attention to the following points:

Unless it does not make sense from the controller's layout (e.g. for record buttons as opposed to a collection of similar elements such as sliders), elements of the same type should be grouped into a hierarchical description for maximum compatibility.

Also, make sure to fill in appropriate descriptions for code::\type:: fields.


subsection:: Testing the description




section:: argTemplate matching

This section gives some examples of how the code::argTemplate:: matching works in link::Classes/OSCdef:: works. In MKtl the code::argTemplate:: follows the same principles.

code::

n = NetAddr.new( "127.0.0.1", NetAddr.langPort );

OSCdef( \test, { |msg| msg.postln; }, "/test", argTemplate: [ 0 ] );

n.sendMsg( "/test", 0, 2 );
n.sendMsg( "/test", 1, 1 );

OSCdef( \test, { |msg| msg.postln; }, "/test", argTemplate: [ "hello" ] );

n.sendMsg( "/test", "hello", 2 );
n.sendMsg( "/test", 1, 1 );

OSCdef( \test, { |msg| msg.postln; }, "/minibee/data", argTemplate: [ 7 ] );

n.sendMsg( "/minibee/data", 7, 0, 0 ,0 ); // matches
n.sendMsg( "/minibee/data", 6, 0, 0 ,0 ); // doesn't match


OSCdef( \test, { |msg| msg.postln; }, "/grid", argTemplate: [ 2, 3 ] );

n.sendMsg( "/grid", 2, 3, 0.4 ); // matches
n.sendMsg( "/grid", 1, 2, 0.2 ); // doesn't match


OSCdef( \test, { |msg| msg.postln; }, "/second", argTemplate: [ nil, [3,2] ] );

n.sendMsg( "/second", 2, 3, 0.4 ); // matches
n.sendMsg( "/second", 2, 2, 0.4 ); // matches
n.sendMsg( "/second", 1, 4, 0.2 ); // doesn't match

::