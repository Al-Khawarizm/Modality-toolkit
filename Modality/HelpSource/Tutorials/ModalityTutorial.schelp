title:: Modality Tutorial
summary:: Learning how to use Modality
categories:: Libraries>Modality, External Control
related:: Overviews/Modality, Classes/MKtl

section:: Discovering and initializing devices

NOTE::If you have a  code::Korg nanoKontrol2:: at hand, you should now plug it in.
Otherwise you can still do this tutorial by using the gui which can replace the device.
::

The first step is to discover which devices are available for use:

code::
MKtl.find;
::

This will find all currently available devices, info on them,
and example lines of code that can generate an MKtl for the device. Each line is code::MKtl('a_shortname', "a_desc_filename")::.

Copy the code::MKtl(...)::-line of the device you want to use from the post window to your document and assign it to a variable.

If you try to create an code::MKtl():: but the device is not connected, you can still create a virtual MKtl and open a GUI for it.

code::
// open the MKtl
k = MKtl('nk2', "korg-nanokontrol2");

// create a gui for it - this can replace the device
k.gui;
::

You can see the output from all elements by doing

code::
//turn it on
k.trace(true);

//turn it off
k.trace(false);
::

section:: Identifying elements

Each control (i.e. knob, slider, button, etc) on the device is mapped to an link::Classes/MKtlElement::. To discover the elements that are available, we look at code::MKtl:elementGroup::.

code::
k.elementGroup;
// print all elements in the top level group:
k.elementGroup.printAll;
k.elementGroup.do(_.printAll); "";
// post the tree of all elements and groups in hierachical order:
k.postElements;
::

This structure is an (link::Classes/MKtlElementGroup::) which can contain nested groups, where the final node is an link::Classes/MKtlElement::. The structure of the groups mimics the spatial and/or logical organization of the controls on the device according to rows, columns and pages.

This structure is defined in the MKtlDesc file for the device:
code::
k.desc.openFile;

code::
//all the base keys
//some are individual elements others are arrays of elements (or arrays of arrays, etc).
k.elementGroup.keys;

//the play button
k.elAt(\tr, \play);

//the first slider
k.elAt(\sl, 0)
k.elAt(\sl, \1)

//all sliders in an array
k.elAt(\sl)

//the third knob
k.elAt(\kn, 2);
k.elAt(\kn, \3);

//the button on row 2 and column 5
//buttons are organized first by rows and then columns.
k.elAt(\bt, 1, 4)
k.elAt(\bt, \M, \5)

//all buttons on row 2
k.elAt(\bt, 1);

//all buttons on column 5
k.elAt(\bt, nil, 4);

//note: this does not work with the nanoKONTROL, which has four hardware scenes.
// There, e.g. in scene 4, the button on row 2 and column 5 would be at:
k.elAt(\bt, 3, 1, 4);
::

section:: Assigning actions

Actions are assigned using either the "action_" or the "addAction" and "resetAction" methods of link::Classes/MKtlElement::. These methods take a function as argument which receives one argument, the link::Classes/MKtlElement::. To extract the current value of the element, one should call ".value". The value returned by an link::Classes/MKtlElement:: is between 0 and 1.

code::

//Assign an action to the third knob
k.elAt(\kn, 2).action_({ |el| el.value.postln });

//To remove all actions
k.elAt(\kn, 2).resetAction;

//Add an action to all knobs
(
k.elAt(\kn).action_({ |el|
	"knob % value: %\n".postf(el.parent.indexOf(el), el.value)
});
)

//to remove the actions
k.elAt(\kn).resetAction;
::

An example with a SynthDef:

NOTE::
For link::Classes/SynthDef:: building see its helpfile.
::

s.boot;

(
SynthDef(\blippy, {
    var out = Blip.ar(\freq.kr(440).lag(0.1), \numHarmonics.kr(100), \amp.kr(1.0).lag(0.1) ) * 0.5;
    Out.ar(0, Pan2.ar(out, \pan.kr(0).lag(0.1) ) )
}).add
);

//start it
x = Synth(\blippy, [\freq, 440, \numHarmonics, 100, \amp, 0.5, \pan, 0]);

(
//clear all actions first
k.resetAction;

//slider 0 -> amplitude
k.elAt(\sl, 0).action_({ |elem| x !? _.set(\amp, \amp.asSpec.map(elem.value)) });

//knob 0 -> pan
k.elAt(\kn, 0).action_({ |elem| x !? _.set(\pan, \pan.asSpec.map(elem.value)) });

//slider 1
k.elAt(\sl, 1).action_({ |elem| x !? _.set(\freq, elem.value.linlin(0.0, 1.0, 50, 2000) ) });

//knob 1 -> number of harmonics
k.elAt(\kn, 1).action_({ |elem| x !? _.set(\numHarmonics, elem.value.linexp(0.0, 1.0, 1, 50) ) });
)

(
// play button -> start and stop synth
k.elAt(\tr, \play).action_({  |elem|
    if(elem.value > 0) {
        x !? _.free;
        x = Synth(\blippy, [\freq, 440, \numHarmonics, 100, \amp, 0.5, \pan, 0])
    } {
        x !? _.free;
        x = nil;
    }
});
);

// clear all functions
k.resetAction;
// stop the synth:
x.free;


// assigning multiple actions can be done with .addAction;
(
k.elAt(\sl, 0).addAction({ |elem| ("1 :"++elem.value).postln });
k.elAt(\sl, 0).addAction({ |elem| ("2 :"++elem.value).postln });
)
//clear all
k.elAt(\sl, 0).resetAction;

/// to remove them you need to have a reference to the function
(
f = { |elem| ("1 :"++elem.value).postln };
g = { |elem| ("2 :"++elem.value).postln };
k.elAt(\sl, 0).addAction(f);
k.elAt(\sl, 0).addAction(g);
)

//remove first action
k.elAt(\sl, 0).removeAction(f);
// just 2 is left

//clear all
k.elAt(\sl, 0).action = nil;


/// =========== output to elements (if you have any on your midi device) =============

// check which inputs are there:
k.inputElements;

// check which outputs are there:
k.outputElements;

// sending data to the output elements
// value range between 0 and 1, will be mapped according to the
// deviceSpec given in the description file
// should set LEDs on all S buttons
/*
k.elAt(\bt, \S).do { |elem| elem.value_(1.0) };
k.elAt(\bt, \S).do { |elem| elem.value_(0.0) };
*/

k.free;