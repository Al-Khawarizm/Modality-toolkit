title:: Modality Tutorial
summary:: Learning how to use Modality
categories:: Libraries>Modality, External Control
related:: Overviews/Modality, Classes/MKtl

section:: Finding present devices

NOTE:: If you have one of the example devices (a Korg nanoKontrol2 MIDI faderbox or a Thrustmaster RunNDrive HID gamepad) at hand, you can plug it in to use a real interface device. If not, you can substitute them with a device you have, or use the MKtl's gui to step through this tutorial.
::

The first step is to discover which devices are available for use:

code::
MKtl.find;
::

This will find all currently available devices, all the known info on them,
and will post example lines of code that can generate an MKtl for the device(s) found.
The recommended line to use is code::MKtl('a_shortname', "a_desc_filename")::.

Copy the code line for the device you want to use from the post window to a text document and assign it to a variable. If you have none, you can also just make a virtual code::MKtl():: and open a GUI for it .

code::
// open the MKtl
k = MKtl('nk2', "korg-nanokontrol2");
// create a gui for it - this can replace the device
k.gui;
::

You can see the output from all elements by doing

code::
//turn it on
k.trace;
//turn it off
k.trace(false);
::

The same for a Thrustmaster RunNDrive gamepad:

code::
g = MKtl(\gp, "*drive");
g.gui;
g.trace;
g.trace(false);
::

section:: Elements and Groups

Each control (i.e. knob, slider, button, etc) on the device is mapped to an link::Classes/MKtlElement::. All elements are contained in the elementGroup, usually in a hierarchical order:

code::
k.elementGroup;
// you can access elements in each group by index or name:
k.elementGroup[0];
k.elementGroup[\tr];
// post the tree of all groups and elements in hierachical order:
k.postElements;
::

This is an (link::Classes/MKtlElementGroup::) and usualy contains nested groups, where the final node is always an link::Classes/MKtlElement::. The structure of the groups mimics the spatial order on the device (rows, columns, areas) or logical order (pages, function groups, etc).

This organization is defined in an link::Classes/MKtlDesc:: file for the device, which are provided for many devices already.
code::
k.desc.openFile;

// the top level keys - some may be individual elements, others groups of elements:
k.elementGroup.keys;

//the play button
k.elAt(\tr, \play);

//the first slider
k.elAt(\sl, 0);
k.elAt(\sl, \1);

//all sliders as a group
k.elAt(\sl);

//the third knob
k.elAt(\kn, 2);
k.elAt(\kn, \3);

//the button on row 2 and column 5
//buttons are organized first by rows and then columns.
k.elAt(\bt, 1, 4)
k.elAt(\bt, \M, \5)

//all buttons on row 2
k.elAt(\bt, 1);

//all buttons on column 5
k.elAt(\bt, nil, 4);
::

Note:: when using devices with hardware pages (like the nanoKONTROL 1), there may be separate desc files for each page, or a single desc with all pages. When using such a single desc, the page name or index will be used in the access code, e.g. the button on page 4 row 2 and column 5 would be at:
code::
// MKtl(\nk1).elAt(\bt, 3, 1, 4);
::
::

section:: Using actions

Actions for an element are defined using "action_" or the "addAction" methods of link::Classes/MKtlElement::. These methods take a function as argument which receives a single argument, the link::Classes/MKtlElement:: it belongs to. One can To extract the current value of the element, one should call ".value". The value returned by an link::Classes/MKtlElement:: is between 0 and 1.

code::

//Assign an action to the third knob
k.elAt(\kn, 2).action_({ |el| [el.name, el.value.round(0.0001)].postcs });

// reset the of this knob to nothing (nil)
k.elAt(\kn, 2).resetAction;

//Add an action to the group of all knobs
(
k.elAt(\kn).action_({ |el|
	"knob % value: %\n".postf(el.parent.indexOf(el), el.value)
});
)

//reset the \kn group's action to nil
k.elAt(\kn).resetAction;
::

section:: Control a simple sound process

code::
s.boot;

// using a very simple SynthDef and Synth:
(
SynthDef(\blippy, {
    var snd = Blip.ar(
		\freq.kr(440).lag(0.1),
		\numHarmonics.kr(100),
		\amp.kr(1.0).lag(0.1) ) * 0.5;
    Out.ar(0,
		Pan2.ar(snd, \pan.kr(0).lag(0.1) )
	)
}).add
);

//start the synth by hand first
~syn1 = Synth(\blippy, [\freq, 440, \numHarmonics, 100, \amp, 0.5, \pan, 0]);


// create 4 control elements for it:
(
//clear all actions first
k.reset;

//slider 0 -> amplitude
k.elAt(\sl, 0).action_({ |elem| ~syn !? _.set(\amp, \amp.asSpec.map(elem.value)) });

//knob 0 -> pan
k.elAt(\kn, 0).action_({ |elem| ~syn !? _.set(\pan, \pan.asSpec.map(elem.value)) });

//slider 1
k.elAt(\sl, 1).action_({ |elem| ~syn !? _.set(\freq, elem.value.linlin(0.0, 1.0, 50, 2000) ) });

//knob 1 -> number of harmonics
k.elAt(\kn, 1).action_({ |elem| ~syn !? _.set(\numHarmonics, elem.value.linexp(0.0, 1.0, 1, 50) ) });
)

// and here a more flexible way to do this:
// give the elements names for their functions, and use those
(
k.addNamed(\amp1, k.elAt(\sl, 0));
k.addNamed(\pan1, k.elAt(\kn, 0));
k.addNamed(\param1, k.elAt(\sl, 1));
k.addNamed(\param2, k.elAt(\kn, 2));

// while at it, prapare buttons for start and stop
k.addNamed(\start1, k.elAt(\bt, \S, 0));
k.addNamed(\stop1, k.elAt(\bt, \R, 0));
)

// give them the same actions as above:
(
k.elAt(\amp1).action_({ |elem| ~syn1 !? _.set(\amp, \amp.asSpec.map(elem.value)) });
k.elAt(\pan1).action_({ |elem| ~syn1 !? _.set(\pan, \pan.asSpec.map(elem.value)) });
k.elAt(\param1).action_({ |elem| ~syn1 !? _.set(\freq, elem.value.linlin(0.0, 1.0, 50, 2000) ) });
k.elAt(\param2).action_({ |elem| ~syn1 !? _.set(\numHarmonics, elem.value.linexp(0.0, 1.0, 1, 50) ) });

// and new functions  for start and stop:
k.elAt(\start1).action_({  |elem|
    if(elem.value > 0) { // only start on button down
        ~syn1 !? _.free;
        ~syn1 = Synth(\blippy, [\freq, 440, \numHarmonics, 100, \amp, 0.5, \pan, 0])
	}
});
k.elAt(\stop1).action_({  |elem|
    if(elem.value > 0) { // only stop on button down
		~syn1 !? _.free; ~syn1 = nil;
	}
});
)
::

section:: Control the same process from a different device

code::
// give the elements of the new controller the same function names:
(
k = MKtl(\gp); // k is now the gamepad we prepared
k.addNamed(\amp1, k.elAt(\joy, \r, \y));
k.elAt;
k.addNamed(\pan1, k.elAt(\joy, \r, \x));
k.addNamed(\param1, k.elAt(\joy, \l, \x));
k.addNamed(\param2, k.elAt(\joy, \l, \y));

// while at it, prapare buttons for start and stop
k.addNamed(\start1, k.elAt(\bt, \5));
k.addNamed(\stop1, k.elAt(\bt, \7));
)

// and now run the same function setting code as above for the gamepad controller:
(
k.elAt(\amp1).action_({ |elem| ~syn1 !? _.set(\amp, \amp.asSpec.map(elem.value)) });
k.elAt(\pan1).action_({ |elem| ~syn1 !? _.set(\pan, \pan.asSpec.map(elem.value)) });
k.elAt(\param1).action_({ |elem| ~syn1 !? _.set(\freq, elem.value.linlin(0.0, 1.0, 50, 2000) ) });
k.elAt(\param2).action_({ |elem| ~syn1 !? _.set(\numHarmonics, elem.value.linexp(0.0, 1.0, 1, 50) ) });

// and new functions  for start and stop:
k.elAt(\start1).action_({  |elem|
    if(elem.value > 0) { // only start on button down
        ~syn1 !? _.free;
        ~syn1 = Synth(\blippy, [\freq, 440, \numHarmonics, 100, \amp, 0.5, \pan, 0])
	}
});
k.elAt(\stop1).action_({  |elem|
    if(elem.value > 0) { // only stop on button down
		~syn1 !? _.free; ~syn1 = nil;
	}
});
)
::

section:: Using multiple actions

For very flexible use of multiple actions, see link::Classes/MFunc:: in the "adclib" Quark.

code::
// Assigning multiple actions to an element can be done with .addAction:
(
k.elAt(\amp1).addAction({ |elem| ("1 :"++elem.value).postln });
k.elAt(\amp1).addAction({ |elem| ("2 :"++elem.value).postln });
)
//clear all
k.elAt(\sl, 0).resetAction;

/// to remove them you need to have a reference to the function
(
f = { |elem| ("1 :"++elem.value).postln };
g = { |elem| ("2 :"++elem.value).postln };
k.elAt(\sl, 0).addAction(f);
k.elAt(\sl, 0).addAction(g);
)

//remove first action
k.elAt(\sl, 0).removeAction(f);
// just action 2 is left

//clear all
k.elAt(\sl, 0).action = nil;

::

section:: Output elements

Some devices can be set to specific values, e.g. setting motorfaders or LED rings around encoder knobs to the corresponding values.

code::
// input elements of the device :
k.inputElements;

// output elements
k.outputElements;

// sending data to the output elements
// value range between 0 and 1, will be mapped according to the
// deviceSpec given in the description file
// here, should set LEDs on all S buttons
/*
MKtl(\nk2).elAt(\bt, \S).do { |elem| elem.value_(1.0) };
MKtl(\nk2).elAt(\bt, \S).do { |elem| elem.value_(0.0) };
*/

k.free;
::