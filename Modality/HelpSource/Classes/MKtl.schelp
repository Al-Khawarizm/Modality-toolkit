CLASS:: MKtl
summary:: A class for creating and accessing external controllers
categories:: Libraries>Modality, External Control
related:: Overviews/Modality, Classes/MKtlDesc, Classes/MKtlDevice, Classes/MKtlElementGroup, Classes/MKtlElement

DESCRIPTION::

NOTE::
For a guided tour, start reading at link::Overviews/Modality::.
::

MKtl provides an easy to use interface for devices you can connect to your computer through MIDI, HID, OSC and eventually Serial and other protocols. Beyond that, you will be able to use it for GUI based controllers (yet to be implemented).

MKtl searches for controllers connected to your machine, and gives you a list of available devices. Or, if you already know which controller you want to use, it will look through this list and returns the controller with that name. If it cannot find it, it will represent the physical controller with a GUI so you can simulate using it.

For most devices, this requires that someone has made a description file for the device; if there is none, it is easy to make one following the instructions here:
link::Tutorials/How_to_create_a_description_file::

MKtls can also be nested by composing several MKtls; for instance, the iControl ... creates both MIDI and HID devices for communication. For an example and background, see link::Tutorials/Composing_MKtls::


CLASSMETHODS::
PRIVATE:: initClass, prAddDefaultSpecs

METHOD:: all
all available MKtl controllers.
code::
MKtl.all;
::


METHOD:: find
Find all currently connected controllers.
This method calls the find method on all of MKtlDevice's subclasses, and will post a list of available MKtl devices.
code::
MKtl.find;
::


METHOD:: new
Accesses an existing instance of MKtl with the given name, or creates a new instance with that name. As with e.g. JITLib proxies like Ndef, Tdef, Pdef, or OSCdef, MIDIdef etc.

code::
// name and name of description file
k = MKtl('mynano2', "korg-nanokontrol2");

// description file name can also contain wildcards:
l = MKtl('op1', "*op-1");

// if you have several devices of the same kind connected,
// say two nanoKontrol2s, you can get to each of them by multiIndex:
m = MKtl('nk2A', "korg-nanokontrol2", multiIndex: 0);
n = MKtl('nk2B', "korg-nanokontrol2", multiIndex: 1);

// Note that this is the index of the list of multiples only,
// and in the order they show up in the system,
// as is posted from MKtl.find. If you connect your
// devices to the same plugs, they will get the same multiIndex again.
::

argument:: name
The name of the controller as you want to refer to it.

argument:: lookupNameOrDesc
The device description that you want to use. This can be the lookupName of a device that was found MKtl.find, the file name of a description file (without extension), an MKtlDesc object, or a dictionary from which a valid device description can be created.

argument:: lookForNew
Boolean flag whether or not to look for newly attached devices or newly added device descriptions. Default is false. It will always look for devices and device descriptions the first time you open an MKtl.

argument:: multiIndex
if several devices of the identical make are used, multiIndex is the index within the array of identical devices. The order depends on USB plug order, but will be reproduceable if the same plugs are used.


SUBSECTION:: Using specs in MKtl

METHOD:: globalSpecs
A class dictionary of all preset ControlSpecs used by various controller elements.

METHOD:: addSpec, getSpec
add and access by name a ControlSpec in MKtl's dictionary of specs

argument:: key
the name by which to store the spec

argument:: spec
The ControlSpec or a symbol or array that can be converted to a spec.
code::
MKtl.globalSpecs;
MKtl.addSpec(\bipolar, [-1, 1]);
MKtl.getSpec(\bipolar);
::


SUBSECTION:: Using description files, interfacing to MKtlDesc

METHOD:: postLoadableDescs
post the filenames of all loadable device descriptions.
For more details on using description files, see link::Classes/MKtlDesc::

METHOD:: postLoadedDescs
post all currently loaded device descriptions.

METHOD:: descFolders
the folder(s) where MKtlDesc finds description files.

METHOD:: openDescFolder
open folder(s) at index containing description files.

METHOD:: loadDescsMatching
load device description file(s) matching with name from indicated folder(s).

Method:: descIsFaulty
test whether the given desc is faulty.

code::
MKtl.postLoadableDescs;
MKtl.postLoadedDescs;
MKtl.descFolders;
MKtl.openDescFolder(0);
MKtl.loadDescsMatching("*run-n-drive*");
::

METHOD:: postPossible
post all possible (i.e. currently connected or known) devices for the protocol(s) given.
MKtl.postPossible;

Method:: makeLookupName
make a lookupName for a device based on (typically) its protocol, id number and productName.
code::
MKtl.makeLookupName(\hid, 0, "Run'N'Drive - Wireless");
MKtl.makeLookupName(\midiSrc, 0, "nanoKEY");
// osc - is ip addr and port good here?
MKtl.makeLookupName(\osc, "127.0.0.1_57110", "sclang");
::

INSTANCEMETHODS::

METHOD:: name
get and set the name of the MKtl.
This also changes the name under which the MKtl is stored in Mktl.all.
code::
MKtl(\test, "korg-nanokontrol2");
MKtl(\test).name_(\mynano2);
MKtl.all; // \test is gone now, use \mynano2 instead
::

argument:: inname
a Symbol.

METHOD:: gui
Open a gui representation for the MKtl
code::
MKtl(\mynano2).gui;
::


METHOD:: specs, addLocalSpec, addSpec, getSpec
a local dict for special specs to use with this MKtl's elements or groups.
code::
MKtl(\mynano2).specs;
MKtl(\mynano2).addSpec(\angle, [-pi, pi]);
MKtl(\mynano2).getSpec(\angle);
::

METHOD:: desc
the MKtlDesc object that holds the device information from the description file.
It is used to build the elements and groups of this MKtl.
code::
a = MKtl(\mynano2).desc;
a.fullDesc;		// a dict built from the description file
a.fullDesc.keys;	// the keys of the items in it
a.protocol;			// e.g. the protocol used
a.elementsDesc; 	// the dict of the elements described
// a.postElements; 	// post element names and keys/indices in hierarchical order
::
For more, see MKtlDesc


METHOD:: openDevice
Open the hardware device for this MKtl if it was not opened already. It will look automatically for an appropriate device.

argument:: lookAgain
Whether or not to look for newly attached hardware devices.

argument:: multiIndex
Needed when using multiple identical devices to identify which one to create.

code::
// while the run'n'drive is not yet attached,
// this creates a virtual device
m = MKtl( 'funky', "*run-n-drive" );
m.clear;
m.trace(true);
HIDFunc.trace(true);
MKtl.all.removeAt(\funky);

// now I found my run'n'drive and plugged it in:
m.openDevice; // finds it automatically

::

METHOD:: closeDevice
Closes the hardware device if it was open.

METHOD:: device, mktlDevice
The instance of MKtlDevice that this MKtl uses.
(mktlDevice is a deprecated alias for device)

METHOD:: free
Frees the MKtl again and forgets about its existence.
If there was an device, this closes it.

METHOD:: reset
Reset all actions of the elements in this MKtl to nil.
(should this include the group actions?)

METHOD:: trace
set flag whether incoming data are posted or not.

METHOD:: traceRunning
Whether or not we are printing incoming data currently.


METHOD::rebuild
If new description given is valid, this will rebuild the elements from the new description.
warning:: This will remove any actions you have attached, so only use this method when you are really sure that you want to replace the device description.::

METHOD::enable, disable
enable and disable this MKtl, so one can make multiple MKtls (with different setups of elements) for the same physical device.

METHOD::sync
send all current MKtl values to the physical device, e.g. to move all motorfaders to a freshly recalled preset.


SUBSECTION:: Elements of the MKtl

METHOD:: elementGroup, elements
All the control elements (MKtlElement) on the device you may want to listen or talk to. this returns an link::Classes/MKtlElementGroup:: containing a hierarchical tree of link::Classes/MKtlElement::s, organised via link::Classes/MKtlElementGroup::.
(elements is a deprecated alias of elementGroup).
code::
MKtl(\funky).elementGroup;
::

METHOD:: namedDict
A dict for adding elements or groups by name, so they can be accessed by name.
For example, this can be used to reorganize the elements of a fader box into channels as on a mixer.


METHOD:: elementNames
An alphabetical list of all elementNames in the MKtl.
m = MKtl(\manta, "*manta*");
m.elementNames;

METHOD:: postElements
A pretty printed hierarchical list of the names and indices of all elements
code::
m = MKtl(\manta, "*manta*");
m.postElements;
::

METHOD:: elementsDict
all elements in one flat event so they can be accessed very fast.
code::
m.elementsDict;
m.dictAt('pad_13_con');


::

METHOD:: inputElements, outputElements
code::
// collect all elements that have inputs:
m.inputElements
//  all elements that have outputs:
m.outputElements
::

METHOD:: elementsOfType, elementsNotOfType
return all elements that are of the type given, or not
code::
m.elementsOfType(\slider);
m.elementsNotOfType(\slider);
::

METHOD:: elementsLabeled
return all elements which have been given a label
code::
o = MKtl(\opi1, "teenage*");
o.elementsLabeled(\white);
::

subsection:: Accessing elements and groups

METHOD:: elAt, elAt
Access an element or group in the elementGroup or in groups by
hierarchical indices or names.
Supports nil and \all as wildcards, and multi-expands correctly.

code::
k = MKtl(\mynano2, "korg-nanokontrol2");
k.elementGroup;
k.elAt; // the same top group

k.elAt(\tr); // the top level group of transport elements
k.elAt(\tr, \rew); // a button in the \tr group

k.elAt(\not, \there); // nil for non-existent names

k.elAt(\sl); // the group of all sliders
k.elAt(\sl, 0); // the first slider by index
k.elAt(\sl, \1); // the first slider by name
k.elementGroup[\sl][0]; // same lookup by hand

k.elAt(\bt); // the group of all buttons
k.elAt(\bt, \S); // the S buttons
k.elAt(\bt, \M, \1); // the first  button

k.elAt(\all, 0); // the first element in every group
k.elAt(nil, 0); // the first element in every group


METHOD:: collAt
Access an element in the collectivesDict by hierarchical name.
See link::Tutorials/Creating_Custom_ElementGroups::

code:: MKtl(\mynano2).collAt(\mixchan, \1, \sl); ::

METHOD:: dictAt
Access an element in the elementsDict directly by its full name.
This is a very fast lookup.
code:: MKtl(\mynano2).dictAt(\sl_1); ::


METHOD:: at
Access an element in the top elementGroup by index.
code:: MKtl(\mynano2).at(0); ::


subsection:: Getting and setting element values

METHOD:: valueAt
Access an element's value by the direct element key

code::
m = MKtl( 'funky', "*run-n-drive" );
m.valueAt( \compass );
m.valueAt( \bt_2 );
::

METHOD:: deviceValueAt
Access an element's deviceValue (in the deviceSpec range) by the element key

code::
m = MKtl( 'funky', "*run-n-drive" );
m.deviceValueAt( \compass );
m.deviceValueAt( \bt_2 );
m.deviceValueAt( \joy_l_x );
::

METHOD:: setValueAt, setDeviceValueAt
Set an element's value or deviceValue directly by element key

subsection:: Getting and setting multiple elements

METHOD:: getKeysValues
get multiple key/value pairs for a list of element keys.
this is intended for more robust storage of presets.
code::
m.getKeysValues; // gets all keys and values
m.getKeysValues( [\compass, \wheel] ); // two elements
m.getKeysValues( [\joy_l_x, \joy_l_y, \joy_r_x, \joy_r_y, ] );
m.getKeysValues( m.elAt(\bt).collect(_.name) ); // the bt group
::

METHOD:: setKeysValues
set multiple key/value pairs from a list of key/value arrays.
code::
m.setKeysValues( [[\compass, 0.125], [\wheel, 1.0]] ); // two elements
m.gui;
::


METHOD:: setKVAction
same as setKeysValues, but with doAction of the elements being set


METHOD:: set
set multiple key/value pairs from a list of key, value arguments.
m.set(\joy_l_x, 1.0.rand, \joy_l_y, 1.0.rand, \joy_r_x,1.0.rand,  \joy_r_y, 1.0.rand);
m.gui;

METHOD:: setAction
same as set, but with doAction of the elements being set

METHOD:: send
Send the value of the element to the hardware device; called if you set the value of an MKtlElement that is an output.

SUBSECTION:: Exploration of a device

See link::Tutorials/How_to_create_a_description_file:: for a full discussion on this.

METHOD:: explore

When a device doesn't have a description file yet, explore can be used to help in creating one.

METHOD:: exploring
Returns a Boolean whether or not a device is currently being explored.

METHOD:: createDescriptionFile
When a device doesn't have a description file yet, this method can be used to create a description file.

METHOD:: specialMessages
a dict of special messages for this device, typically to change setup on a MIDI device by sending it a sysex message.

METHOD:: sendSpecialMessage
send specialMessage with that name to the device


Subsection:: Collectives and Composite MKtl

... create collectives in new mktl - to be written.
METHOD:: collectivesDict, collectiveDescriptionFor

Methods for finding info on available devices in MKtlLookup.
METHOD:: lookupInfo, lookupName, updateLookupInfo

Method:: midiPortNameIndex
needed for identifying multiple midi devices

Various tests
METHOD:: checkAllCtls, checkIdentical, hasDevice

private:: wrapCollElemsInGroups, specialMessageNames, sendSpecialMessage, prMatchedElements
PRIVATE:: storeArgs, printOn, init, makeElements, makeCollectives, finishInit


Method::addNamed
add an element or group to the mktl's namedDict,
so they can be accessed by user given names.

This can be used to name single elements by the same function name
across different devices - e.g. call one button \play, another \stop,
no matter what its name in the device description may be:

k = MKtl(\nk2, "*trol2");
k.elAt(\tr, \play);
k.addNamed(\play, k.elAt(\tr, \play));
k.elAt(\play);
k.elAt(\play) === k.elAt(\tr, \play);

For longer examples of adding custom groups, see examples section.

EXAMPLES::

code::
// giving elements custom access names:

// in a nanoKontrol2, put all transport buttons (in group \tr)
// in k.namedDict, so they can be accessed without the \tr prefix:
k = MKtl(\nk2, "*trol2");
k.elAt(\tr).do { |el| k.addNamed(el.elemDesc.key, el); };
k.namedDict.keys;
k.elAt(\stop);


// An example for making a new group and adding it -
// a mixer with 8 channels each consisting of one slider and one knob:

k = MKtl(\nk2, "*trol2");

// the elements as flopped array
k.elAt([\sl, \kn], (0..7)).flop.choose;

// make nested element groups from them:
// assocs are needed so that lookup by name is generated
// (maybe add elAtAsAssoc method that returns assocs?
(
m = MKtlElementGroup(\mix, k,
	k.elAt([\sl, \kn], (0..7)).flop.collect { |pair, i|
		var name = (i+1).asSymbol;
		name -> MKtlElementGroup(name, k,
			pair.collect { |el, i| [\sl, \kn][i] -> el }
		);
});
k.addNamed(\mix, m);
)
k.elAt(\mix);
k.elAt(\mix, 0)
k.elAt(\mix, \1)
k.elAt(\mix, 0)
k.elAt(\mix, \1, \kn)
k.elAt(\mix, \1, 1)

// TODO: example with button groups included in mixer channels ...
::