CLASS:: MKtlElement
summary:: An element of an MKtl.
categories:: Libraries>Modality
related:: Overviews/Modality, Classes/MAbstractElement, Classes/MKtl

DESCRIPTION::
An element of an link::Classes/MKtl::.


CLASSMETHODS::

METHOD:: types
Available types.

private:: initClass

METHOD:: new
creates a new instance.

argument:: source
The link::Classes/MKtl:: it belongs to.

argument:: name
A name.

INSTANCEMETHODS::

METHOD:: spec

returns:: the element's spec

private:: init

METHOD:: defaultValue

returns:: the element's default value

METHOD:: value

returns:: the element's current value (normed)

METHOD:: rawValue

argument:: newVal
sets the element's value (raw)

returns:: the element's current value (raw)

argument:: newval
Float [0.0-1.0]

returns:: MKtlElement

discussion::

This will not cause the action to be performed.

If the element is of type inout or out then the value will also be sent back to the control. Value should be in 0.0-1.0 range, it will be automatically mapped to the correct range for this device (e.g. 0-127).

Example:
Control a knob on the Behringer BCF2000

code::
MIDIMKtl('bcf20000').elements.at(\kn_1_1).value_(0.5)
::


METHOD:: rawValue

Set the value to the element.

argument:: newval
Number in the range expected by the device

returns:: MKtlElement

discussion::

This will not cause the action to be performed and will not send the value back to the device.



EXAMPLES::

Sending data back to MIDI device, one should use link::Classes/MAbstractElement#value_:: :

MIDIMKtl('bcf20000').elementAt(\kn,1,i+1).value_(0.5)

Classic knobs rotating demo for B:

code::
(
x = 0;
fork{
	loop{
		0.1.wait;
		x = x + 0.1;
		8.do{ |i|
			MIDIMKtl('bcf20000').elementAt(\kn,1,i+1).value_(
				(x + (i/7)).mod(1.0)
			)
		}
	}
}
)
::